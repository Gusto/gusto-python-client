"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from gusto import models, utils
from gusto._hooks import HookContext
from gusto.types import OptionalNullable, UNSET
from gusto.utils import get_security_from_env
from typing import Any, List, Mapping, Optional, Union


class Employees(BaseSDK):
    def post_v1_employees(
        self,
        *,
        company_id: str,
        first_name: str,
        last_name: str,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        middle_initial: Optional[str] = None,
        preferred_first_name: Optional[str] = None,
        date_of_birth: Optional[str] = None,
        email: Optional[str] = None,
        ssn: Optional[str] = None,
        self_onboarding: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Employee:
        r"""Create an employee

        Create an employee.

        scope: `employees:manage`

        :param company_id: The UUID of the company
        :param first_name:
        :param last_name:
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param middle_initial:
        :param preferred_first_name:
        :param date_of_birth:
        :param email: The employee's personal email address.
        :param ssn:
        :param self_onboarding: If true, employee is expected to self-onboard. If false, payroll admin is expected to enter in the employee's onboarding information
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PostV1EmployeesRequest(
            company_id=company_id,
            x_gusto_api_version=x_gusto_api_version,
            request_body=models.PostV1EmployeesRequestBody(
                first_name=first_name,
                middle_initial=middle_initial,
                last_name=last_name,
                preferred_first_name=preferred_first_name,
                date_of_birth=date_of_birth,
                email=email,
                ssn=ssn,
                self_onboarding=self_onboarding,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/companies/{company_id}/employees",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                models.PostV1EmployeesRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="post-v1-employees",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Employee)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def post_v1_employees_async(
        self,
        *,
        company_id: str,
        first_name: str,
        last_name: str,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        middle_initial: Optional[str] = None,
        preferred_first_name: Optional[str] = None,
        date_of_birth: Optional[str] = None,
        email: Optional[str] = None,
        ssn: Optional[str] = None,
        self_onboarding: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Employee:
        r"""Create an employee

        Create an employee.

        scope: `employees:manage`

        :param company_id: The UUID of the company
        :param first_name:
        :param last_name:
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param middle_initial:
        :param preferred_first_name:
        :param date_of_birth:
        :param email: The employee's personal email address.
        :param ssn:
        :param self_onboarding: If true, employee is expected to self-onboard. If false, payroll admin is expected to enter in the employee's onboarding information
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PostV1EmployeesRequest(
            company_id=company_id,
            x_gusto_api_version=x_gusto_api_version,
            request_body=models.PostV1EmployeesRequestBody(
                first_name=first_name,
                middle_initial=middle_initial,
                last_name=last_name,
                preferred_first_name=preferred_first_name,
                date_of_birth=date_of_birth,
                email=email,
                ssn=ssn,
                self_onboarding=self_onboarding,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/companies/{company_id}/employees",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                models.PostV1EmployeesRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="post-v1-employees",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Employee)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def list(
        self,
        *,
        company_id: str,
        terminated: Optional[bool] = None,
        include: Optional[List[models.Include]] = None,
        page: Optional[float] = None,
        per: Optional[float] = None,
        search_term: Optional[str] = None,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.Employee]:
        r"""Get employees of a company

        Get all of the employees, onboarding, active and terminated, for a given company.

        scope: `employees:read`

        :param company_id: The UUID of the company
        :param terminated: Filters employees by the provided boolean
        :param include: Include the requested attribute(s) in each employee response, multiple options are comma separated. Available options: - all_compensations: Include all effective dated compensations for each job instead of only the current compensation - custom_fields: Include employees' custom fields
        :param page: The page that is requested. When unspecified, will load all objects unless endpoint forces pagination.
        :param per: Number of objects per page. For majority of endpoints will default to 25
        :param search_term: A string to search for in the object's names
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetV1CompaniesCompanyIDEmployeesRequest(
            company_id=company_id,
            terminated=terminated,
            include=include,
            page=page,
            per=per,
            search_term=search_term,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request(
            method="GET",
            path="/v1/companies/{company_id}/employees",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="get-v1-companies-company_id-employees",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, List[models.Employee])
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def list_async(
        self,
        *,
        company_id: str,
        terminated: Optional[bool] = None,
        include: Optional[List[models.Include]] = None,
        page: Optional[float] = None,
        per: Optional[float] = None,
        search_term: Optional[str] = None,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.Employee]:
        r"""Get employees of a company

        Get all of the employees, onboarding, active and terminated, for a given company.

        scope: `employees:read`

        :param company_id: The UUID of the company
        :param terminated: Filters employees by the provided boolean
        :param include: Include the requested attribute(s) in each employee response, multiple options are comma separated. Available options: - all_compensations: Include all effective dated compensations for each job instead of only the current compensation - custom_fields: Include employees' custom fields
        :param page: The page that is requested. When unspecified, will load all objects unless endpoint forces pagination.
        :param per: Number of objects per page. For majority of endpoints will default to 25
        :param search_term: A string to search for in the object's names
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetV1CompaniesCompanyIDEmployeesRequest(
            company_id=company_id,
            terminated=terminated,
            include=include,
            page=page,
            per=per,
            search_term=search_term,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/companies/{company_id}/employees",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="get-v1-companies-company_id-employees",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, List[models.Employee])
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def post_v1_historical_employees(
        self,
        *,
        company_uuid: str,
        first_name: str,
        last_name: str,
        date_of_birth: str,
        ssn: str,
        work_address: Union[models.WorkAddress, models.WorkAddressTypedDict],
        home_address: Union[
            models.HistoricalEmployeeBodyHomeAddress,
            models.HistoricalEmployeeBodyHomeAddressTypedDict,
        ],
        termination: Union[
            models.HistoricalEmployeeBodyTermination,
            models.HistoricalEmployeeBodyTerminationTypedDict,
        ],
        job: Union[
            models.HistoricalEmployeeBodyJob, models.HistoricalEmployeeBodyJobTypedDict
        ],
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        middle_initial: Optional[str] = None,
        preferred_first_name: Optional[str] = None,
        email: Optional[str] = None,
        employee_state_taxes: Optional[
            Union[models.EmployeeStateTaxes, models.EmployeeStateTaxesTypedDict]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Employee:
        r"""Create a historical employee

        Create a historical employee, an employee that was previously dismissed from the company in the current year.

        scope: `employees:manage`

        :param company_uuid: The UUID of the company
        :param first_name:
        :param last_name:
        :param date_of_birth:
        :param ssn:
        :param work_address:
        :param home_address:
        :param termination:
        :param job:
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param middle_initial:
        :param preferred_first_name:
        :param email: Optional. If provided, the email address will be saved to the employee.
        :param employee_state_taxes:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PostV1HistoricalEmployeesRequest(
            company_uuid=company_uuid,
            x_gusto_api_version=x_gusto_api_version,
            historical_employee_body=models.HistoricalEmployeeBody(
                first_name=first_name,
                middle_initial=middle_initial,
                last_name=last_name,
                preferred_first_name=preferred_first_name,
                date_of_birth=date_of_birth,
                ssn=ssn,
                work_address=utils.get_pydantic_model(work_address, models.WorkAddress),
                home_address=utils.get_pydantic_model(
                    home_address, models.HistoricalEmployeeBodyHomeAddress
                ),
                termination=utils.get_pydantic_model(
                    termination, models.HistoricalEmployeeBodyTermination
                ),
                email=email,
                job=utils.get_pydantic_model(job, models.HistoricalEmployeeBodyJob),
                employee_state_taxes=utils.get_pydantic_model(
                    employee_state_taxes, Optional[models.EmployeeStateTaxes]
                ),
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/companies/{company_uuid}/historical_employees",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.historical_employee_body,
                False,
                False,
                "json",
                models.HistoricalEmployeeBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="post-v1-historical_employees",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Employee)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def post_v1_historical_employees_async(
        self,
        *,
        company_uuid: str,
        first_name: str,
        last_name: str,
        date_of_birth: str,
        ssn: str,
        work_address: Union[models.WorkAddress, models.WorkAddressTypedDict],
        home_address: Union[
            models.HistoricalEmployeeBodyHomeAddress,
            models.HistoricalEmployeeBodyHomeAddressTypedDict,
        ],
        termination: Union[
            models.HistoricalEmployeeBodyTermination,
            models.HistoricalEmployeeBodyTerminationTypedDict,
        ],
        job: Union[
            models.HistoricalEmployeeBodyJob, models.HistoricalEmployeeBodyJobTypedDict
        ],
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        middle_initial: Optional[str] = None,
        preferred_first_name: Optional[str] = None,
        email: Optional[str] = None,
        employee_state_taxes: Optional[
            Union[models.EmployeeStateTaxes, models.EmployeeStateTaxesTypedDict]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Employee:
        r"""Create a historical employee

        Create a historical employee, an employee that was previously dismissed from the company in the current year.

        scope: `employees:manage`

        :param company_uuid: The UUID of the company
        :param first_name:
        :param last_name:
        :param date_of_birth:
        :param ssn:
        :param work_address:
        :param home_address:
        :param termination:
        :param job:
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param middle_initial:
        :param preferred_first_name:
        :param email: Optional. If provided, the email address will be saved to the employee.
        :param employee_state_taxes:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PostV1HistoricalEmployeesRequest(
            company_uuid=company_uuid,
            x_gusto_api_version=x_gusto_api_version,
            historical_employee_body=models.HistoricalEmployeeBody(
                first_name=first_name,
                middle_initial=middle_initial,
                last_name=last_name,
                preferred_first_name=preferred_first_name,
                date_of_birth=date_of_birth,
                ssn=ssn,
                work_address=utils.get_pydantic_model(work_address, models.WorkAddress),
                home_address=utils.get_pydantic_model(
                    home_address, models.HistoricalEmployeeBodyHomeAddress
                ),
                termination=utils.get_pydantic_model(
                    termination, models.HistoricalEmployeeBodyTermination
                ),
                email=email,
                job=utils.get_pydantic_model(job, models.HistoricalEmployeeBodyJob),
                employee_state_taxes=utils.get_pydantic_model(
                    employee_state_taxes, Optional[models.EmployeeStateTaxes]
                ),
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/companies/{company_uuid}/historical_employees",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.historical_employee_body,
                False,
                False,
                "json",
                models.HistoricalEmployeeBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="post-v1-historical_employees",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Employee)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def update_historical_employee(
        self,
        *,
        company_uuid: str,
        historical_employee_uuid: str,
        version: str,
        first_name: str,
        last_name: str,
        date_of_birth: str,
        ssn: str,
        work_address: Union[
            models.PutV1HistoricalEmployeesWorkAddress,
            models.PutV1HistoricalEmployeesWorkAddressTypedDict,
        ],
        home_address: Union[
            models.PutV1HistoricalEmployeesHomeAddress,
            models.PutV1HistoricalEmployeesHomeAddressTypedDict,
        ],
        termination: Union[
            models.PutV1HistoricalEmployeesTermination,
            models.PutV1HistoricalEmployeesTerminationTypedDict,
        ],
        job: Union[
            models.PutV1HistoricalEmployeesJob,
            models.PutV1HistoricalEmployeesJobTypedDict,
        ],
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        middle_initial: Optional[str] = None,
        preferred_first_name: Optional[str] = None,
        email: Optional[str] = None,
        employee_state_taxes: Optional[
            Union[
                models.PutV1HistoricalEmployeesEmployeeStateTaxes,
                models.PutV1HistoricalEmployeesEmployeeStateTaxesTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Employee:
        r"""Update a historical employee

        Update a historical employee, an employee that was previously dismissed from the company in the current year.

        scope: `employees:manage`

        :param company_uuid: The UUID of the company
        :param historical_employee_uuid: The UUID of the historical employee
        :param version: The current version of the object. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
        :param first_name:
        :param last_name:
        :param date_of_birth:
        :param ssn:
        :param work_address:
        :param home_address:
        :param termination:
        :param job:
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param middle_initial:
        :param preferred_first_name:
        :param email: Optional. If provided, the email address will be saved to the employee.
        :param employee_state_taxes:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PutV1HistoricalEmployeesRequest(
            company_uuid=company_uuid,
            historical_employee_uuid=historical_employee_uuid,
            x_gusto_api_version=x_gusto_api_version,
            request_body=models.PutV1HistoricalEmployeesRequestBody(
                version=version,
                first_name=first_name,
                middle_initial=middle_initial,
                last_name=last_name,
                preferred_first_name=preferred_first_name,
                date_of_birth=date_of_birth,
                ssn=ssn,
                work_address=utils.get_pydantic_model(
                    work_address, models.PutV1HistoricalEmployeesWorkAddress
                ),
                home_address=utils.get_pydantic_model(
                    home_address, models.PutV1HistoricalEmployeesHomeAddress
                ),
                termination=utils.get_pydantic_model(
                    termination, models.PutV1HistoricalEmployeesTermination
                ),
                email=email,
                job=utils.get_pydantic_model(job, models.PutV1HistoricalEmployeesJob),
                employee_state_taxes=utils.get_pydantic_model(
                    employee_state_taxes,
                    Optional[models.PutV1HistoricalEmployeesEmployeeStateTaxes],
                ),
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/v1/companies/{company_uuid}/historical_employees/{historical_employee_uuid}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                models.PutV1HistoricalEmployeesRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="put-v1-historical_employees",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Employee)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def update_historical_employee_async(
        self,
        *,
        company_uuid: str,
        historical_employee_uuid: str,
        version: str,
        first_name: str,
        last_name: str,
        date_of_birth: str,
        ssn: str,
        work_address: Union[
            models.PutV1HistoricalEmployeesWorkAddress,
            models.PutV1HistoricalEmployeesWorkAddressTypedDict,
        ],
        home_address: Union[
            models.PutV1HistoricalEmployeesHomeAddress,
            models.PutV1HistoricalEmployeesHomeAddressTypedDict,
        ],
        termination: Union[
            models.PutV1HistoricalEmployeesTermination,
            models.PutV1HistoricalEmployeesTerminationTypedDict,
        ],
        job: Union[
            models.PutV1HistoricalEmployeesJob,
            models.PutV1HistoricalEmployeesJobTypedDict,
        ],
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        middle_initial: Optional[str] = None,
        preferred_first_name: Optional[str] = None,
        email: Optional[str] = None,
        employee_state_taxes: Optional[
            Union[
                models.PutV1HistoricalEmployeesEmployeeStateTaxes,
                models.PutV1HistoricalEmployeesEmployeeStateTaxesTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Employee:
        r"""Update a historical employee

        Update a historical employee, an employee that was previously dismissed from the company in the current year.

        scope: `employees:manage`

        :param company_uuid: The UUID of the company
        :param historical_employee_uuid: The UUID of the historical employee
        :param version: The current version of the object. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
        :param first_name:
        :param last_name:
        :param date_of_birth:
        :param ssn:
        :param work_address:
        :param home_address:
        :param termination:
        :param job:
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param middle_initial:
        :param preferred_first_name:
        :param email: Optional. If provided, the email address will be saved to the employee.
        :param employee_state_taxes:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PutV1HistoricalEmployeesRequest(
            company_uuid=company_uuid,
            historical_employee_uuid=historical_employee_uuid,
            x_gusto_api_version=x_gusto_api_version,
            request_body=models.PutV1HistoricalEmployeesRequestBody(
                version=version,
                first_name=first_name,
                middle_initial=middle_initial,
                last_name=last_name,
                preferred_first_name=preferred_first_name,
                date_of_birth=date_of_birth,
                ssn=ssn,
                work_address=utils.get_pydantic_model(
                    work_address, models.PutV1HistoricalEmployeesWorkAddress
                ),
                home_address=utils.get_pydantic_model(
                    home_address, models.PutV1HistoricalEmployeesHomeAddress
                ),
                termination=utils.get_pydantic_model(
                    termination, models.PutV1HistoricalEmployeesTermination
                ),
                email=email,
                job=utils.get_pydantic_model(job, models.PutV1HistoricalEmployeesJob),
                employee_state_taxes=utils.get_pydantic_model(
                    employee_state_taxes,
                    Optional[models.PutV1HistoricalEmployeesEmployeeStateTaxes],
                ),
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/v1/companies/{company_uuid}/historical_employees/{historical_employee_uuid}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                models.PutV1HistoricalEmployeesRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="put-v1-historical_employees",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Employee)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get(
        self,
        *,
        employee_id: str,
        include: Optional[List[models.QueryParamInclude]] = None,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Employee:
        r"""Get an employee

        Get an employee.

        scope: `employees:read`


        :param employee_id: The UUID of the employee
        :param include: Include the requested attribute(s) in each employee response, multiple options are comma separated. Available options: - all_compensations: Include all effective dated compensations for each job instead of only the current compensation - custom_fields: Include employees' custom fields
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetV1EmployeesRequest(
            employee_id=employee_id,
            include=include,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request(
            method="GET",
            path="/v1/employees/{employee_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="get-v1-employees",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Employee)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_async(
        self,
        *,
        employee_id: str,
        include: Optional[List[models.QueryParamInclude]] = None,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Employee:
        r"""Get an employee

        Get an employee.

        scope: `employees:read`


        :param employee_id: The UUID of the employee
        :param include: Include the requested attribute(s) in each employee response, multiple options are comma separated. Available options: - all_compensations: Include all effective dated compensations for each job instead of only the current compensation - custom_fields: Include employees' custom fields
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetV1EmployeesRequest(
            employee_id=employee_id,
            include=include,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/employees/{employee_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="get-v1-employees",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Employee)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def put_v1_employees(
        self,
        *,
        employee_id: str,
        version: str,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        first_name: Optional[str] = None,
        middle_initial: Optional[str] = None,
        last_name: Optional[str] = None,
        preferred_first_name: Optional[str] = None,
        date_of_birth: Optional[str] = None,
        email: Optional[str] = None,
        ssn: Optional[str] = None,
        two_percent_shareholder: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Employee:
        r"""Update an employee

        Update an employee.

        scope: `employees:write`

        :param employee_id: The UUID of the employee
        :param version: The current version of the object. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/versioning#object-layer) for information on how to use this field.
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param first_name:
        :param middle_initial:
        :param last_name:
        :param preferred_first_name:
        :param date_of_birth:
        :param email: The employee's personal email address.
        :param ssn:
        :param two_percent_shareholder: Whether the employee is a two percent shareholder of the company. This field only applies to companies with an S-Corp entity type.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PutV1EmployeesRequest(
            employee_id=employee_id,
            x_gusto_api_version=x_gusto_api_version,
            request_body=models.PutV1EmployeesRequestBody(
                version=version,
                first_name=first_name,
                middle_initial=middle_initial,
                last_name=last_name,
                preferred_first_name=preferred_first_name,
                date_of_birth=date_of_birth,
                email=email,
                ssn=ssn,
                two_percent_shareholder=two_percent_shareholder,
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/v1/employees/{employee_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                models.PutV1EmployeesRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="put-v1-employees",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Employee)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def put_v1_employees_async(
        self,
        *,
        employee_id: str,
        version: str,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        first_name: Optional[str] = None,
        middle_initial: Optional[str] = None,
        last_name: Optional[str] = None,
        preferred_first_name: Optional[str] = None,
        date_of_birth: Optional[str] = None,
        email: Optional[str] = None,
        ssn: Optional[str] = None,
        two_percent_shareholder: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Employee:
        r"""Update an employee

        Update an employee.

        scope: `employees:write`

        :param employee_id: The UUID of the employee
        :param version: The current version of the object. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/versioning#object-layer) for information on how to use this field.
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param first_name:
        :param middle_initial:
        :param last_name:
        :param preferred_first_name:
        :param date_of_birth:
        :param email: The employee's personal email address.
        :param ssn:
        :param two_percent_shareholder: Whether the employee is a two percent shareholder of the company. This field only applies to companies with an S-Corp entity type.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PutV1EmployeesRequest(
            employee_id=employee_id,
            x_gusto_api_version=x_gusto_api_version,
            request_body=models.PutV1EmployeesRequestBody(
                version=version,
                first_name=first_name,
                middle_initial=middle_initial,
                last_name=last_name,
                preferred_first_name=preferred_first_name,
                date_of_birth=date_of_birth,
                email=email,
                ssn=ssn,
                two_percent_shareholder=two_percent_shareholder,
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/v1/employees/{employee_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                models.PutV1EmployeesRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="put-v1-employees",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Employee)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def delete_v1_employee(
        self,
        *,
        employee_id: str,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete an onboarding employee

        Use this endpoint to delete an employee who is in onboarding. Deleting
        an onboarded employee is not allowed and will return a 422 response. Please check out the Terminations api
        if you need to terminate an onboarded employee.

        scope: `employees:manage`

        :param employee_id: The UUID of the employee
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.DeleteV1EmployeeRequest(
            employee_id=employee_id,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request(
            method="DELETE",
            path="/v1/employees/{employee_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="delete-v1-employee",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def delete_v1_employee_async(
        self,
        *,
        employee_id: str,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete an onboarding employee

        Use this endpoint to delete an employee who is in onboarding. Deleting
        an onboarded employee is not allowed and will return a 422 response. Please check out the Terminations api
        if you need to terminate an onboarded employee.

        scope: `employees:manage`

        :param employee_id: The UUID of the employee
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.DeleteV1EmployeeRequest(
            employee_id=employee_id,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/v1/employees/{employee_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="delete-v1-employee",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_v1_employees_employee_id_custom_fields(
        self,
        *,
        employee_id: str,
        page: Optional[float] = None,
        per: Optional[float] = None,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetV1EmployeesEmployeeIDCustomFieldsResponseBody:
        r"""Get an employee's custom fields

        Returns a list of the employee's custom fields.

        scope: `employees:read`

        :param employee_id: The UUID of the employee
        :param page: The page that is requested. When unspecified, will load all objects unless endpoint forces pagination.
        :param per: Number of objects per page. For majority of endpoints will default to 25
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetV1EmployeesEmployeeIDCustomFieldsRequest(
            employee_id=employee_id,
            page=page,
            per=per,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request(
            method="GET",
            path="/v1/employees/{employee_id}/custom_fields",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="get-v1-employees-employee_id-custom_fields",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.GetV1EmployeesEmployeeIDCustomFieldsResponseBody
            )
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_v1_employees_employee_id_custom_fields_async(
        self,
        *,
        employee_id: str,
        page: Optional[float] = None,
        per: Optional[float] = None,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetV1EmployeesEmployeeIDCustomFieldsResponseBody:
        r"""Get an employee's custom fields

        Returns a list of the employee's custom fields.

        scope: `employees:read`

        :param employee_id: The UUID of the employee
        :param page: The page that is requested. When unspecified, will load all objects unless endpoint forces pagination.
        :param per: Number of objects per page. For majority of endpoints will default to 25
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetV1EmployeesEmployeeIDCustomFieldsRequest(
            employee_id=employee_id,
            page=page,
            per=per,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/employees/{employee_id}/custom_fields",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="get-v1-employees-employee_id-custom_fields",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.GetV1EmployeesEmployeeIDCustomFieldsResponseBody
            )
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_v1_employees_employee_id_onboarding_status(
        self,
        *,
        employee_id: str,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EmployeeOnboardingStatus:
        r"""Get the employee's onboarding status

        # Description
        Retrieves an employee's onboarding status. The data returned helps inform the required onboarding steps and respective completion status.

        scope: `employees:read`

        ## onboarding_status

        ### Admin-facilitated onboarding
        | onboarding_status | Description |
        |:------------------|------------:|
        | `admin_onboarding_incomplete` | Admin needs to complete the full employee-onboarding. |
        | `onboarding_completed` | Employee has been fully onboarded and verified. |

        ### Employee self-onboarding
        | onboarding_status | Description |
        |:------------------|------------:|
        | `admin_onboarding_incomplete` | Admin needs to enter basic information about the employee. |
        | `self_onboarding_pending_invite` | Admin has the intention to invite the employee to self-onboard (e.g., marking a checkbox), but the system has not yet sent the invitation. |
        | `self_onboarding_invited` | Employee has been sent an invitation to self-onboard. |
        | `self_onboarding_invited_started` | Employee has started the self-onboarding process. |
        | `self_onboarding_invited_overdue` | Employee's start date has passed, and employee has still not completed self-onboarding. |
        | `self_onboarding_completed_by_employee` | Employee has completed entering in their information. The status should be updated via API to \"self_onboarding_awaiting_admin_review\" from here, once the Admin has started reviewing. |
        | `self_onboarding_awaiting_admin_review` | Admin has started to verify the employee's information. |
        | `onboarding_completed` | Employee has been fully onboarded and verified. |

        ## onboarding_steps

        | onboarding_steps | Requirement(s) to be completed |
        |:-----------------|-------------------------------:|
        | `personal_details` | Add employee's first name, last name, email, date of birth, social security number |
        | `compensation_details` | Associate employee to a job & compensation. |
        | `add_work_address` | Add employee work address. |
        | `add_home_address` | Add employee home address. |
        | `federal_tax_setup` | Set up federal tax withholdings. |
        | `state_tax_setup` | Set up state tax withholdings. |
        | `direct_deposit_setup` | (optional) Set up employee's direct deposit. |
        | `employee_form_signing` | Employee forms (e.g., W4, direct deposit authorization) are generated & signed. |
        | `file_new_hire_report` | File a new hire report for this employee. |
        | `admin_review` | Admin reviews & confirms employee details (only required for Employee self-onboarding) |

        :param employee_id: The UUID of the employee
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetV1EmployeesEmployeeIDOnboardingStatusRequest(
            employee_id=employee_id,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request(
            method="GET",
            path="/v1/employees/{employee_id}/onboarding_status",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="get-v1-employees-employee_id-onboarding_status",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.EmployeeOnboardingStatus)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_v1_employees_employee_id_onboarding_status_async(
        self,
        *,
        employee_id: str,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EmployeeOnboardingStatus:
        r"""Get the employee's onboarding status

        # Description
        Retrieves an employee's onboarding status. The data returned helps inform the required onboarding steps and respective completion status.

        scope: `employees:read`

        ## onboarding_status

        ### Admin-facilitated onboarding
        | onboarding_status | Description |
        |:------------------|------------:|
        | `admin_onboarding_incomplete` | Admin needs to complete the full employee-onboarding. |
        | `onboarding_completed` | Employee has been fully onboarded and verified. |

        ### Employee self-onboarding
        | onboarding_status | Description |
        |:------------------|------------:|
        | `admin_onboarding_incomplete` | Admin needs to enter basic information about the employee. |
        | `self_onboarding_pending_invite` | Admin has the intention to invite the employee to self-onboard (e.g., marking a checkbox), but the system has not yet sent the invitation. |
        | `self_onboarding_invited` | Employee has been sent an invitation to self-onboard. |
        | `self_onboarding_invited_started` | Employee has started the self-onboarding process. |
        | `self_onboarding_invited_overdue` | Employee's start date has passed, and employee has still not completed self-onboarding. |
        | `self_onboarding_completed_by_employee` | Employee has completed entering in their information. The status should be updated via API to \"self_onboarding_awaiting_admin_review\" from here, once the Admin has started reviewing. |
        | `self_onboarding_awaiting_admin_review` | Admin has started to verify the employee's information. |
        | `onboarding_completed` | Employee has been fully onboarded and verified. |

        ## onboarding_steps

        | onboarding_steps | Requirement(s) to be completed |
        |:-----------------|-------------------------------:|
        | `personal_details` | Add employee's first name, last name, email, date of birth, social security number |
        | `compensation_details` | Associate employee to a job & compensation. |
        | `add_work_address` | Add employee work address. |
        | `add_home_address` | Add employee home address. |
        | `federal_tax_setup` | Set up federal tax withholdings. |
        | `state_tax_setup` | Set up state tax withholdings. |
        | `direct_deposit_setup` | (optional) Set up employee's direct deposit. |
        | `employee_form_signing` | Employee forms (e.g., W4, direct deposit authorization) are generated & signed. |
        | `file_new_hire_report` | File a new hire report for this employee. |
        | `admin_review` | Admin reviews & confirms employee details (only required for Employee self-onboarding) |

        :param employee_id: The UUID of the employee
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetV1EmployeesEmployeeIDOnboardingStatusRequest(
            employee_id=employee_id,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/employees/{employee_id}/onboarding_status",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="get-v1-employees-employee_id-onboarding_status",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.EmployeeOnboardingStatus)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def put_v1_employees_employee_id_onboarding_status(
        self,
        *,
        employee_id: str,
        onboarding_status: str,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EmployeeOnboardingStatus:
        r"""Update the employee's onboarding status

        scope: `employees:manage`

        Updates an employee's onboarding status.
        Below is a list of valid onboarding status changes depending on the intended action to be performed on behalf of the employee.

        | Action | current onboarding_status | new onboarding_status |
        |:------------------|:------------:|----------:|
        | Mark an employee as self-onboarding | `admin_onboarding_incomplete` | `self_onboarding_pending_invite` |
        | Invite an employee to self-onboard | `admin_onboarding_incomplete` or `self_onboarding_pending_invite` | `self_onboarding_invited` |
        | Cancel an employee's self-onboarding | `self_onboarding_invited` or `self_onboarding_pending_invite` | `admin_onboarding_incomplete` |
        | Review an employee's self-onboarded info | `self_onboarding_completed_by_employee` | `self_onboarding_awaiting_admin_review` |
        | Finish an employee's onboarding | `admin_onboarding_incomplete` or `self_onboarding_awaiting_admin_review` | `onboarding_completed` |

        :param employee_id: The UUID of the employee
        :param onboarding_status: The updated onboarding status for the employee
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PutV1EmployeesEmployeeIDOnboardingStatusRequest(
            employee_id=employee_id,
            x_gusto_api_version=x_gusto_api_version,
            request_body=models.PutV1EmployeesEmployeeIDOnboardingStatusRequestBody(
                onboarding_status=onboarding_status,
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/v1/employees/{employee_id}/onboarding_status",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                models.PutV1EmployeesEmployeeIDOnboardingStatusRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="put-v1-employees-employee_id-onboarding_status",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.EmployeeOnboardingStatus)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def put_v1_employees_employee_id_onboarding_status_async(
        self,
        *,
        employee_id: str,
        onboarding_status: str,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EmployeeOnboardingStatus:
        r"""Update the employee's onboarding status

        scope: `employees:manage`

        Updates an employee's onboarding status.
        Below is a list of valid onboarding status changes depending on the intended action to be performed on behalf of the employee.

        | Action | current onboarding_status | new onboarding_status |
        |:------------------|:------------:|----------:|
        | Mark an employee as self-onboarding | `admin_onboarding_incomplete` | `self_onboarding_pending_invite` |
        | Invite an employee to self-onboard | `admin_onboarding_incomplete` or `self_onboarding_pending_invite` | `self_onboarding_invited` |
        | Cancel an employee's self-onboarding | `self_onboarding_invited` or `self_onboarding_pending_invite` | `admin_onboarding_incomplete` |
        | Review an employee's self-onboarded info | `self_onboarding_completed_by_employee` | `self_onboarding_awaiting_admin_review` |
        | Finish an employee's onboarding | `admin_onboarding_incomplete` or `self_onboarding_awaiting_admin_review` | `onboarding_completed` |

        :param employee_id: The UUID of the employee
        :param onboarding_status: The updated onboarding status for the employee
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PutV1EmployeesEmployeeIDOnboardingStatusRequest(
            employee_id=employee_id,
            x_gusto_api_version=x_gusto_api_version,
            request_body=models.PutV1EmployeesEmployeeIDOnboardingStatusRequestBody(
                onboarding_status=onboarding_status,
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/v1/employees/{employee_id}/onboarding_status",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                models.PutV1EmployeesEmployeeIDOnboardingStatusRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="put-v1-employees-employee_id-onboarding_status",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.EmployeeOnboardingStatus)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_version_employees_time_off_activities(
        self,
        *,
        employee_uuid: str,
        time_off_type: str,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TimeOffActivity:
        r"""Get employee time off activities

        Get employee time off activities.

        scope: `employee_time_off_activities:read`

        :param employee_uuid: The UUID of the employee
        :param time_off_type: The time off type name you want to query data for. ex: 'sick' or 'vacation'
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetVersionEmployeesTimeOffActivitiesRequest(
            employee_uuid=employee_uuid,
            time_off_type=time_off_type,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request(
            method="GET",
            path="/v1/employees/{employee_uuid}/time_off_activities",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="get-version-employees-time_off_activities",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.TimeOffActivity)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_version_employees_time_off_activities_async(
        self,
        *,
        employee_uuid: str,
        time_off_type: str,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TimeOffActivity:
        r"""Get employee time off activities

        Get employee time off activities.

        scope: `employee_time_off_activities:read`

        :param employee_uuid: The UUID of the employee
        :param time_off_type: The time off type name you want to query data for. ex: 'sick' or 'vacation'
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetVersionEmployeesTimeOffActivitiesRequest(
            employee_uuid=employee_uuid,
            time_off_type=time_off_type,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/employees/{employee_uuid}/time_off_activities",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="get-version-employees-time_off_activities",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.TimeOffActivity)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def post_v1_employees_employee_id_rehire(
        self,
        *,
        employee_id: str,
        effective_date: str,
        file_new_hire_report: bool,
        work_location_uuid: str,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        employment_status: Optional[models.EmploymentStatus] = None,
        two_percent_shareholder: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Rehire:
        r"""Create an employee rehire

        Rehire is created whenever an employee is scheduled to return to the company.

        scope: `employments:write`

        :param employee_id: The UUID of the employee
        :param effective_date: The day when the employee returns to work.
        :param file_new_hire_report: The boolean flag indicating whether Gusto will file a new hire report for the employee.
        :param work_location_uuid: The uuid of the employee's work location.
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param employment_status: The employee's employment status. Supplying an invalid option will set the employment_status to *not_set*.
        :param two_percent_shareholder: Whether the employee is a two percent shareholder of the company. This field only applies to companies with an S-Corp entity type.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PostV1EmployeesEmployeeIDRehireRequest(
            employee_id=employee_id,
            x_gusto_api_version=x_gusto_api_version,
            rehire_body=models.RehireBody(
                effective_date=effective_date,
                file_new_hire_report=file_new_hire_report,
                work_location_uuid=work_location_uuid,
                employment_status=employment_status,
                two_percent_shareholder=two_percent_shareholder,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/employees/{employee_id}/rehire",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.rehire_body, False, False, "json", models.RehireBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="post-v1-employees-employee_id-rehire",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Rehire)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def post_v1_employees_employee_id_rehire_async(
        self,
        *,
        employee_id: str,
        effective_date: str,
        file_new_hire_report: bool,
        work_location_uuid: str,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        employment_status: Optional[models.EmploymentStatus] = None,
        two_percent_shareholder: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Rehire:
        r"""Create an employee rehire

        Rehire is created whenever an employee is scheduled to return to the company.

        scope: `employments:write`

        :param employee_id: The UUID of the employee
        :param effective_date: The day when the employee returns to work.
        :param file_new_hire_report: The boolean flag indicating whether Gusto will file a new hire report for the employee.
        :param work_location_uuid: The uuid of the employee's work location.
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param employment_status: The employee's employment status. Supplying an invalid option will set the employment_status to *not_set*.
        :param two_percent_shareholder: Whether the employee is a two percent shareholder of the company. This field only applies to companies with an S-Corp entity type.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PostV1EmployeesEmployeeIDRehireRequest(
            employee_id=employee_id,
            x_gusto_api_version=x_gusto_api_version,
            rehire_body=models.RehireBody(
                effective_date=effective_date,
                file_new_hire_report=file_new_hire_report,
                work_location_uuid=work_location_uuid,
                employment_status=employment_status,
                two_percent_shareholder=two_percent_shareholder,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/employees/{employee_id}/rehire",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.rehire_body, False, False, "json", models.RehireBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="post-v1-employees-employee_id-rehire",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Rehire)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def calculate_accruing_time_off_hours(
        self,
        *,
        payroll_id: str,
        employee_id: str,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        regular_hours_worked: Optional[float] = None,
        overtime_hours_worked: Optional[float] = None,
        double_overtime_hours_worked: Optional[float] = None,
        pto_hours_used: Optional[float] = None,
        sick_hours_used: Optional[float] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AccruingTimeOffHour]:
        r"""Calculate accruing time off hours

        Returns a list of accruing time off for each time off policy associated with the employee.

        Factors affecting the accrued hours:
        * the time off policy accrual method (whether they get pay per hour worked, per hour paid, with / without overtime, accumulate time off based on pay period / calendar year / anniversary)
        * how many hours of work during this pay period
        * how many hours of PTO / sick hours taken during this pay period (for per hour paid policies only)
        * company pay schedule frequency (for per pay period)

        If none of the parameters is passed in, the accrued time off hour will be 0.

        scope: `payrolls:read`

        :param payroll_id: The UUID of the payroll
        :param employee_id: The UUID of the employee
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param regular_hours_worked: regular hours worked in this pay period
        :param overtime_hours_worked: overtime hours worked in this pay period
        :param double_overtime_hours_worked: double overtime hours worked in this pay period
        :param pto_hours_used: paid time off hours used in this pay period
        :param sick_hours_used: sick hours used in this pay period
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PostV1PayrollsPayrollIDCalculateAccruingTimeOffHoursRequest(
            payroll_id=payroll_id,
            employee_id=employee_id,
            x_gusto_api_version=x_gusto_api_version,
            request_body=models.PostV1PayrollsPayrollIDCalculateAccruingTimeOffHoursRequestBody(
                regular_hours_worked=regular_hours_worked,
                overtime_hours_worked=overtime_hours_worked,
                double_overtime_hours_worked=double_overtime_hours_worked,
                pto_hours_used=pto_hours_used,
                sick_hours_used=sick_hours_used,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/payrolls/{payroll_id}/employees/{employee_id}/calculate_accruing_time_off_hours",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                models.PostV1PayrollsPayrollIDCalculateAccruingTimeOffHoursRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="post-v1-payrolls-payroll_id-calculate_accruing_time_off_hours",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, List[models.AccruingTimeOffHour])
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def calculate_accruing_time_off_hours_async(
        self,
        *,
        payroll_id: str,
        employee_id: str,
        x_gusto_api_version: Optional[models.VersionHeader] = None,
        regular_hours_worked: Optional[float] = None,
        overtime_hours_worked: Optional[float] = None,
        double_overtime_hours_worked: Optional[float] = None,
        pto_hours_used: Optional[float] = None,
        sick_hours_used: Optional[float] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AccruingTimeOffHour]:
        r"""Calculate accruing time off hours

        Returns a list of accruing time off for each time off policy associated with the employee.

        Factors affecting the accrued hours:
        * the time off policy accrual method (whether they get pay per hour worked, per hour paid, with / without overtime, accumulate time off based on pay period / calendar year / anniversary)
        * how many hours of work during this pay period
        * how many hours of PTO / sick hours taken during this pay period (for per hour paid policies only)
        * company pay schedule frequency (for per pay period)

        If none of the parameters is passed in, the accrued time off hour will be 0.

        scope: `payrolls:read`

        :param payroll_id: The UUID of the payroll
        :param employee_id: The UUID of the employee
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param regular_hours_worked: regular hours worked in this pay period
        :param overtime_hours_worked: overtime hours worked in this pay period
        :param double_overtime_hours_worked: double overtime hours worked in this pay period
        :param pto_hours_used: paid time off hours used in this pay period
        :param sick_hours_used: sick hours used in this pay period
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PostV1PayrollsPayrollIDCalculateAccruingTimeOffHoursRequest(
            payroll_id=payroll_id,
            employee_id=employee_id,
            x_gusto_api_version=x_gusto_api_version,
            request_body=models.PostV1PayrollsPayrollIDCalculateAccruingTimeOffHoursRequestBody(
                regular_hours_worked=regular_hours_worked,
                overtime_hours_worked=overtime_hours_worked,
                double_overtime_hours_worked=double_overtime_hours_worked,
                pto_hours_used=pto_hours_used,
                sick_hours_used=sick_hours_used,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/payrolls/{payroll_id}/employees/{employee_id}/calculate_accruing_time_off_hours",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                models.PostV1PayrollsPayrollIDCalculateAccruingTimeOffHoursRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="post-v1-payrolls-payroll_id-calculate_accruing_time_off_hours",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, List[models.AccruingTimeOffHour])
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )
