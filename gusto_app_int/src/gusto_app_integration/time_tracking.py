"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from datetime import datetime
from gusto_app_integration import models, utils
from gusto_app_integration._hooks import HookContext
from gusto_app_integration.types import OptionalNullable, UNSET
from typing import Any, Dict, List, Mapping, Optional, Union


class TimeTracking(BaseSDK):
    def get_companies_company_uuid_time_tracking_time_sheets(
        self,
        *,
        company_uuid: str,
        entity_uuids: Optional[List[str]] = None,
        entity_type: Optional[models.EntityType] = None,
        status: Optional[models.Status] = None,
        sort_by: Optional[models.TimeSheetSortBy] = None,
        sort_order: Optional[models.TimeSheetSortOrder] = None,
        before: Optional[str] = None,
        after: Optional[str] = None,
        page: Optional[int] = None,
        per: Optional[int] = None,
        x_gusto_api_version: Optional[
            models.VersionHeader
        ] = models.VersionHeader.TWO_THOUSAND_AND_TWENTY_FOUR_MINUS_04_MINUS_01,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.TimeSheet]:
        r"""Get all time sheets for a company

        Fetch all company's time sheets.

        Time sheets represent the time worked by an employee or contractor for a given time range.
        Hours are classified by pay classification, and can be regular, overtime, or double overtime.

        scope: `time_sheet:read`

        :param company_uuid: The UUID of the company
        :param entity_uuids: Entity UUIDs that reported time sheets
        :param entity_type: Type of entities to filter. One of: \"Employee\", \"Contractor\"
        :param status: Status of time sheets. One of: \"approved\", \"pending\", \"rejected\"
        :param sort_by: Field to sort by. One of: \"created_at\", \"updated_at\", \"shift_started_at\", \"shift_ended_at\"
        :param sort_order: Sortinng order. One of: \"asc\", \"desc\"
        :param before: time sheets that were created before ISO 8601 timestamp. Filtering by \"created_at\"
        :param after: time sheets that were created before ISO 8601 timestamp. Filtering by \"created_at\"
        :param page: The page that is requested. When unspecified, will load all objects unless endpoint forces pagination.
        :param per: Number of objects per page. For majority of endpoints will default to 25
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetCompaniesCompanyUUIDTimeTrackingTimeSheetsRequest(
            company_uuid=company_uuid,
            entity_uuids=entity_uuids,
            entity_type=entity_type,
            status=status,
            sort_by=sort_by,
            sort_order=sort_order,
            before=before,
            after=after,
            page=page,
            per=per,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request(
            method="GET",
            path="/v1/companies/{company_uuid}/time_tracking/time_sheets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="get-companies-company_uuid-time_tracking-time_sheets",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, List[models.TimeSheet])
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_companies_company_uuid_time_tracking_time_sheets_async(
        self,
        *,
        company_uuid: str,
        entity_uuids: Optional[List[str]] = None,
        entity_type: Optional[models.EntityType] = None,
        status: Optional[models.Status] = None,
        sort_by: Optional[models.TimeSheetSortBy] = None,
        sort_order: Optional[models.TimeSheetSortOrder] = None,
        before: Optional[str] = None,
        after: Optional[str] = None,
        page: Optional[int] = None,
        per: Optional[int] = None,
        x_gusto_api_version: Optional[
            models.VersionHeader
        ] = models.VersionHeader.TWO_THOUSAND_AND_TWENTY_FOUR_MINUS_04_MINUS_01,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.TimeSheet]:
        r"""Get all time sheets for a company

        Fetch all company's time sheets.

        Time sheets represent the time worked by an employee or contractor for a given time range.
        Hours are classified by pay classification, and can be regular, overtime, or double overtime.

        scope: `time_sheet:read`

        :param company_uuid: The UUID of the company
        :param entity_uuids: Entity UUIDs that reported time sheets
        :param entity_type: Type of entities to filter. One of: \"Employee\", \"Contractor\"
        :param status: Status of time sheets. One of: \"approved\", \"pending\", \"rejected\"
        :param sort_by: Field to sort by. One of: \"created_at\", \"updated_at\", \"shift_started_at\", \"shift_ended_at\"
        :param sort_order: Sortinng order. One of: \"asc\", \"desc\"
        :param before: time sheets that were created before ISO 8601 timestamp. Filtering by \"created_at\"
        :param after: time sheets that were created before ISO 8601 timestamp. Filtering by \"created_at\"
        :param page: The page that is requested. When unspecified, will load all objects unless endpoint forces pagination.
        :param per: Number of objects per page. For majority of endpoints will default to 25
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetCompaniesCompanyUUIDTimeTrackingTimeSheetsRequest(
            company_uuid=company_uuid,
            entity_uuids=entity_uuids,
            entity_type=entity_type,
            status=status,
            sort_by=sort_by,
            sort_order=sort_order,
            before=before,
            after=after,
            page=page,
            per=per,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/companies/{company_uuid}/time_tracking/time_sheets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="get-companies-company_uuid-time_tracking-time_sheets",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, List[models.TimeSheet])
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def post_companies_company_uuid_time_tracking_time_sheets(
        self,
        *,
        company_uuid: str,
        entity_uuid: str,
        entity_type: str,
        time_zone: str,
        shift_started_at: datetime,
        x_gusto_api_version: Optional[
            models.VersionHeader
        ] = models.VersionHeader.TWO_THOUSAND_AND_TWENTY_FOUR_MINUS_04_MINUS_01,
        job_uuid: Optional[str] = None,
        shift_ended_at: Optional[datetime] = None,
        metadata: Optional[Dict[str, str]] = None,
        entries: Optional[
            Union[
                List[models.PostCompaniesCompanyUUIDTimeTrackingTimeSheetsEntries],
                List[
                    models.PostCompaniesCompanyUUIDTimeTrackingTimeSheetsEntriesTypedDict
                ],
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TimeSheet:
        r"""Create a time sheet

        Create a time sheet for a company.

        Time sheets represent the time worked by an employee or contractor for a given time range.
        Hours are classified by pay classification, and can be regular, overtime, or double overtime.

        scope: `time_sheet:write`

        :param company_uuid: The UUID of the company
        :param entity_uuid: Unique identifier of the entity associated with the time sheet.
        :param entity_type: Type of entity associated with the time sheet.
        :param time_zone: Time zone of where the time is tracked.
        :param shift_started_at: ISO 8601 timestamp of when the shift was started.
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param job_uuid: Unique identifier of the job for which time is tracked.
        :param shift_ended_at: ISO 8601 timestamp of when the shift was ended. If the shift is still ongoing you can omit this field.
        :param metadata: Metadata associated with the time sheet. Key-value pairs of arbitrary data. Both keys and values must be strings.
        :param entries: Entries associated with the time sheet.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PostCompaniesCompanyUUIDTimeTrackingTimeSheetsRequest(
            company_uuid=company_uuid,
            x_gusto_api_version=x_gusto_api_version,
            request_body=models.PostCompaniesCompanyUUIDTimeTrackingTimeSheetsRequestBody(
                entity_uuid=entity_uuid,
                entity_type=entity_type,
                job_uuid=job_uuid,
                time_zone=time_zone,
                shift_started_at=shift_started_at,
                shift_ended_at=shift_ended_at,
                metadata=metadata,
                entries=utils.get_pydantic_model(
                    entries,
                    Optional[
                        List[
                            models.PostCompaniesCompanyUUIDTimeTrackingTimeSheetsEntries
                        ]
                    ],
                ),
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/companies/{company_uuid}/time_tracking/time_sheets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                True,
                "json",
                Optional[
                    models.PostCompaniesCompanyUUIDTimeTrackingTimeSheetsRequestBody
                ],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="post-companies-company_uuid-time_tracking-time_sheets",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return utils.unmarshal_json(http_res.text, models.TimeSheet)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def post_companies_company_uuid_time_tracking_time_sheets_async(
        self,
        *,
        company_uuid: str,
        entity_uuid: str,
        entity_type: str,
        time_zone: str,
        shift_started_at: datetime,
        x_gusto_api_version: Optional[
            models.VersionHeader
        ] = models.VersionHeader.TWO_THOUSAND_AND_TWENTY_FOUR_MINUS_04_MINUS_01,
        job_uuid: Optional[str] = None,
        shift_ended_at: Optional[datetime] = None,
        metadata: Optional[Dict[str, str]] = None,
        entries: Optional[
            Union[
                List[models.PostCompaniesCompanyUUIDTimeTrackingTimeSheetsEntries],
                List[
                    models.PostCompaniesCompanyUUIDTimeTrackingTimeSheetsEntriesTypedDict
                ],
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TimeSheet:
        r"""Create a time sheet

        Create a time sheet for a company.

        Time sheets represent the time worked by an employee or contractor for a given time range.
        Hours are classified by pay classification, and can be regular, overtime, or double overtime.

        scope: `time_sheet:write`

        :param company_uuid: The UUID of the company
        :param entity_uuid: Unique identifier of the entity associated with the time sheet.
        :param entity_type: Type of entity associated with the time sheet.
        :param time_zone: Time zone of where the time is tracked.
        :param shift_started_at: ISO 8601 timestamp of when the shift was started.
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param job_uuid: Unique identifier of the job for which time is tracked.
        :param shift_ended_at: ISO 8601 timestamp of when the shift was ended. If the shift is still ongoing you can omit this field.
        :param metadata: Metadata associated with the time sheet. Key-value pairs of arbitrary data. Both keys and values must be strings.
        :param entries: Entries associated with the time sheet.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PostCompaniesCompanyUUIDTimeTrackingTimeSheetsRequest(
            company_uuid=company_uuid,
            x_gusto_api_version=x_gusto_api_version,
            request_body=models.PostCompaniesCompanyUUIDTimeTrackingTimeSheetsRequestBody(
                entity_uuid=entity_uuid,
                entity_type=entity_type,
                job_uuid=job_uuid,
                time_zone=time_zone,
                shift_started_at=shift_started_at,
                shift_ended_at=shift_ended_at,
                metadata=metadata,
                entries=utils.get_pydantic_model(
                    entries,
                    Optional[
                        List[
                            models.PostCompaniesCompanyUUIDTimeTrackingTimeSheetsEntries
                        ]
                    ],
                ),
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/companies/{company_uuid}/time_tracking/time_sheets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                True,
                "json",
                Optional[
                    models.PostCompaniesCompanyUUIDTimeTrackingTimeSheetsRequestBody
                ],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="post-companies-company_uuid-time_tracking-time_sheets",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return utils.unmarshal_json(http_res.text, models.TimeSheet)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_time_tracking_time_sheets_time_sheet_uuid(
        self,
        *,
        time_sheet_uuid: str,
        x_gusto_api_version: Optional[
            models.VersionHeader
        ] = models.VersionHeader.TWO_THOUSAND_AND_TWENTY_FOUR_MINUS_04_MINUS_01,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TimeSheet:
        r"""Get a time sheet

        Fetch a time sheet.

        Time sheets represent the time worked by an employee or contractor for a given time range.
        Hours are classified by pay classification, and can be regular, overtime, or double overtime.

        scope: `time_sheet:read`

        :param time_sheet_uuid: UUID of the time sheet
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetTimeTrackingTimeSheetsTimeSheetUUIDRequest(
            time_sheet_uuid=time_sheet_uuid,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request(
            method="GET",
            path="/v1/time_tracking/time_sheets/{time_sheet_uuid}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="get-time_tracking-time_sheets-time_sheet_uuid",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.TimeSheet)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_time_tracking_time_sheets_time_sheet_uuid_async(
        self,
        *,
        time_sheet_uuid: str,
        x_gusto_api_version: Optional[
            models.VersionHeader
        ] = models.VersionHeader.TWO_THOUSAND_AND_TWENTY_FOUR_MINUS_04_MINUS_01,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TimeSheet:
        r"""Get a time sheet

        Fetch a time sheet.

        Time sheets represent the time worked by an employee or contractor for a given time range.
        Hours are classified by pay classification, and can be regular, overtime, or double overtime.

        scope: `time_sheet:read`

        :param time_sheet_uuid: UUID of the time sheet
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetTimeTrackingTimeSheetsTimeSheetUUIDRequest(
            time_sheet_uuid=time_sheet_uuid,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/time_tracking/time_sheets/{time_sheet_uuid}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="get-time_tracking-time_sheets-time_sheet_uuid",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.TimeSheet)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def put_time_tracking_time_sheets_time_sheet_uuid(
        self,
        *,
        time_sheet_uuid: str,
        version: str,
        x_gusto_api_version: Optional[
            models.VersionHeader
        ] = models.VersionHeader.TWO_THOUSAND_AND_TWENTY_FOUR_MINUS_04_MINUS_01,
        entity_uuid: Optional[str] = None,
        entity_type: Optional[str] = None,
        job_uuid: Optional[str] = None,
        time_zone: Optional[str] = None,
        shift_started_at: Optional[datetime] = None,
        shift_ended_at: Optional[datetime] = None,
        metadata: Optional[Dict[str, str]] = None,
        entries: Optional[
            Union[
                List[models.PutTimeTrackingTimeSheetsTimeSheetUUIDEntries],
                List[models.PutTimeTrackingTimeSheetsTimeSheetUUIDEntriesTypedDict],
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TimeSheet:
        r"""Update a time sheet

        Update a time sheet.

        Time sheets represent the time worked by an employee or contractor for a given time range.
        Hours are classified by pay classification, and can be regular, overtime, or double overtime.

        scope: `time_sheet:write`

        :param time_sheet_uuid: UUID of the time sheet
        :param version: The current version of the object. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param entity_uuid: Unique identifier of the entity associated with the time sheet.
        :param entity_type: Type of entity associated with the time sheet.
        :param job_uuid: Unique identifier of the job for which time was tracked. Currently is only supported for employees.
        :param time_zone: Time zone of where the time was tracked.
        :param shift_started_at: The start time of the shift. Timestamp should be in ISO8601
        :param shift_ended_at: The end time of the shift. If the shift is still ongoing this will be null.
        :param metadata: Metadata associated with the time sheet. Key-value pairs of arbitrary data. Both keys and values must be strings.
        :param entries: Entries associated with the time sheet.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PutTimeTrackingTimeSheetsTimeSheetUUIDRequest(
            time_sheet_uuid=time_sheet_uuid,
            x_gusto_api_version=x_gusto_api_version,
            request_body=models.PutTimeTrackingTimeSheetsTimeSheetUUIDRequestBody(
                version=version,
                entity_uuid=entity_uuid,
                entity_type=entity_type,
                job_uuid=job_uuid,
                time_zone=time_zone,
                shift_started_at=shift_started_at,
                shift_ended_at=shift_ended_at,
                metadata=metadata,
                entries=utils.get_pydantic_model(
                    entries,
                    Optional[
                        List[models.PutTimeTrackingTimeSheetsTimeSheetUUIDEntries]
                    ],
                ),
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/v1/time_tracking/time_sheets/{time_sheet_uuid}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                True,
                "json",
                Optional[models.PutTimeTrackingTimeSheetsTimeSheetUUIDRequestBody],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="put-time_tracking-time_sheets-time_sheet_uuid",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.TimeSheet)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def put_time_tracking_time_sheets_time_sheet_uuid_async(
        self,
        *,
        time_sheet_uuid: str,
        version: str,
        x_gusto_api_version: Optional[
            models.VersionHeader
        ] = models.VersionHeader.TWO_THOUSAND_AND_TWENTY_FOUR_MINUS_04_MINUS_01,
        entity_uuid: Optional[str] = None,
        entity_type: Optional[str] = None,
        job_uuid: Optional[str] = None,
        time_zone: Optional[str] = None,
        shift_started_at: Optional[datetime] = None,
        shift_ended_at: Optional[datetime] = None,
        metadata: Optional[Dict[str, str]] = None,
        entries: Optional[
            Union[
                List[models.PutTimeTrackingTimeSheetsTimeSheetUUIDEntries],
                List[models.PutTimeTrackingTimeSheetsTimeSheetUUIDEntriesTypedDict],
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TimeSheet:
        r"""Update a time sheet

        Update a time sheet.

        Time sheets represent the time worked by an employee or contractor for a given time range.
        Hours are classified by pay classification, and can be regular, overtime, or double overtime.

        scope: `time_sheet:write`

        :param time_sheet_uuid: UUID of the time sheet
        :param version: The current version of the object. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param entity_uuid: Unique identifier of the entity associated with the time sheet.
        :param entity_type: Type of entity associated with the time sheet.
        :param job_uuid: Unique identifier of the job for which time was tracked. Currently is only supported for employees.
        :param time_zone: Time zone of where the time was tracked.
        :param shift_started_at: The start time of the shift. Timestamp should be in ISO8601
        :param shift_ended_at: The end time of the shift. If the shift is still ongoing this will be null.
        :param metadata: Metadata associated with the time sheet. Key-value pairs of arbitrary data. Both keys and values must be strings.
        :param entries: Entries associated with the time sheet.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PutTimeTrackingTimeSheetsTimeSheetUUIDRequest(
            time_sheet_uuid=time_sheet_uuid,
            x_gusto_api_version=x_gusto_api_version,
            request_body=models.PutTimeTrackingTimeSheetsTimeSheetUUIDRequestBody(
                version=version,
                entity_uuid=entity_uuid,
                entity_type=entity_type,
                job_uuid=job_uuid,
                time_zone=time_zone,
                shift_started_at=shift_started_at,
                shift_ended_at=shift_ended_at,
                metadata=metadata,
                entries=utils.get_pydantic_model(
                    entries,
                    Optional[
                        List[models.PutTimeTrackingTimeSheetsTimeSheetUUIDEntries]
                    ],
                ),
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/v1/time_tracking/time_sheets/{time_sheet_uuid}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                True,
                "json",
                Optional[models.PutTimeTrackingTimeSheetsTimeSheetUUIDRequestBody],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="put-time_tracking-time_sheets-time_sheet_uuid",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.TimeSheet)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def delete_time_tracking_time_sheets_time_sheet_uuid(
        self,
        *,
        time_sheet_uuid: str,
        version: str,
        x_gusto_api_version: Optional[
            models.VersionHeader
        ] = models.VersionHeader.TWO_THOUSAND_AND_TWENTY_FOUR_MINUS_04_MINUS_01,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete a time sheet

        Delete a company's time sheet.

        Time sheets represent the time worked by an employee or contractor for a given time range.
        Hours are classified by pay classification, and can be regular, overtime, or double overtime.

        scope: `time_sheet:write`

        :param time_sheet_uuid: UUID of the time sheet
        :param version: The current version of the object. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteTimeTrackingTimeSheetsTimeSheetUUIDRequest(
            time_sheet_uuid=time_sheet_uuid,
            version=version,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request(
            method="DELETE",
            path="/v1/time_tracking/time_sheets/{time_sheet_uuid}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="delete-time_tracking-time_sheets-time_sheet_uuid",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def delete_time_tracking_time_sheets_time_sheet_uuid_async(
        self,
        *,
        time_sheet_uuid: str,
        version: str,
        x_gusto_api_version: Optional[
            models.VersionHeader
        ] = models.VersionHeader.TWO_THOUSAND_AND_TWENTY_FOUR_MINUS_04_MINUS_01,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete a time sheet

        Delete a company's time sheet.

        Time sheets represent the time worked by an employee or contractor for a given time range.
        Hours are classified by pay classification, and can be regular, overtime, or double overtime.

        scope: `time_sheet:write`

        :param time_sheet_uuid: UUID of the time sheet
        :param version: The current version of the object. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
        :param x_gusto_api_version: Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteTimeTrackingTimeSheetsTimeSheetUUIDRequest(
            time_sheet_uuid=time_sheet_uuid,
            version=version,
            x_gusto_api_version=x_gusto_api_version,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/v1/time_tracking/time_sheets/{time_sheet_uuid}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="delete-time_tracking-time_sheets-time_sheet_uuid",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.UnprocessableEntityErrorObjectData
            )
            raise models.UnprocessableEntityErrorObject(data=response_data)
        if utils.match_response(http_res, ["404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )
